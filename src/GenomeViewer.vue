<template>

  <SettingsUI @settings-event="handleSettingsEvent" :settings="settings" />

  <ChromosomeViewer v-for="(item,index) in sortedData" :key="item.id" :datum="item" :domain_max="domain_max" :settings="settings" @chromosome-event="handleChromosomeEvent(index, $event)"  />

</template>

<script>
import 'bootstrap-icons/font/bootstrap-icons.css'
import 'bootstrap/dist/css/bootstrap.css'
import 'bootstrap'

import SettingsUI from './components/Settings.vue'
import ChromosomeViewer from './components/Chromosome.vue'
import * as d3 from 'd3';
import * as perlin from './perlin.js';

export default {
  name: 'GenomeViewer',
  components: {
    SettingsUI,
    ChromosomeViewer
  },
  props: {
    jsonData: Object,
    user_settings: Object,
  },
  data() {
    return {
      settings: {
        // GENERAL SETTINGS
        'type_chromosome': 'extant',
        'sorting_chromosome': 'size',
        'min_genes': 100,
        'type_position': 'loci',
        'hide': false, // detail view
        'mode': 'zoom',
        'defaut_gene_color': 'lightgrey',

        // DATUM RELATED SETTINGS
        states_color_genes:  [null, 'datum1', 'datum2'], // TODO SHOULD BE AUTOGENERATED

        // OVERVIEW SETTINGS
        'svgHeight_overview': 40,
        'colorAccessor_overview': null,
        'heightAccessor_overview': null,
        'brushed_gene_color': 'salmon',

        // MAPPER SETTINGS
        'svgHeight_mapper' :42,

        // EXCERPT SETTINGS
        'svgHeight': 80,
        'colorAccessor_excerpt': null,
        'heightAccessor_excerpt': null,
        'selected_gene_color': 'olive'
      },
      index_color_genes_overview: 0,
      index_sorting: 0,
      states_sorting:  ['size', 'number_genes', 'name'],
      render_data: this.jsonData
    }
  },
  created() {
    this.configure_settings_user()
    this.prepare_data()
  },
  methods: {
    handleChromosomeEvent(index, { eventType, payload }) {
      switch (eventType) {
        case 'updateZoom':
          this.updateZoom(index, payload)
          break;
        case 'domainChanged':
          this.updateDomain(index, payload)
          break;
        case 'updateDomain':
          this.updateDomain(index, payload)
          break;
        case 'addSelectedRegions':
          this.addSelectedRegions(index, payload)
          break;
      }
    },
    // UI EVENT HANDLERS
    handleSettingsEvent({ eventType, payload }) {
      switch (eventType) {
        case 'toggle-type':
          this.toggleType();
          break;
        case 'toggle-hide':
          this.toggleHide();
          break;
        case 'toggle-sorting':
          this.toggleSorting();
          break;
        case 'toggle-mode':
          this.toggleMode();
          break;
        case 'update-color-overview':
          this.toggleColorOverview(payload);
          break;
        case 'update-height-overview':
          this.toggleHeightOverview(payload);
          break;
        case 'update-color-excerpt':
          this.toggleColorExcerpt(payload);
          break;
        case 'update-height-excerpt':
          this.toggleHeightExcerpt(payload);
          break;
      }
    },
    toggleColorExcerpt(selectedOption) {
      this.settings.colorAccessor_excerpt = selectedOption;
    },
    toggleHeightExcerpt(selectedOption) {
      this.settings.heightAccessor_excerpt = selectedOption;
    },
    toggleColorOverview(selectedOption) {
      this.settings.colorAccessor_overview = selectedOption;
    },
    toggleHeightOverview(selectedOption) {
      this.settings.heightAccessor_overview = selectedOption;
    },
    toggleMode() {
      this.settings.mode = this.settings.mode === 'zoom' ? 'brush' : 'zoom';
    },
    toggleSorting(){
      this.index_sorting = ++this.index_sorting%this.states_sorting.length;
      this.settings.sorting_chromosome  = this.states_sorting[this.index_sorting];
    },
    toggleType(){
      this.settings.type_position = this.settings.type_position === 'loci' ? 'index' : 'loci'
    },
    toggleHide(){
      this.settings.hide = this.settings.hide ? false: true
    },

    // FACTORY METHODS
    process_extant(datum) {
      // Process the data for extant chromosomes
      datum.size_in_bp =  Math.max(...datum.nodes.map(d => d.end))
      datum.size_in_genes = datum.nodes.length
      datum.domain = null
      datum.selectedRegions = []
      datum.currentZoom = d3.zoomIdentity
      datum.unique_id = this.generateUniqueId()
      datum.type = 'extant'

      // Add index to the nodes based on start asc sorting
      datum.nodes = datum.nodes.sort((a, b) => a.start - b.start).map((d, i) => {
        d.index = i
        return d
      })

      datum.nodes.forEach(gene => {
        gene.data = {
          'datum1' : perlin.simplex2(0, gene.index),
          'datum2' : perlin.simplex2(0, 10000000 * gene.index),
          'datum3' : perlin.simplex2(0, 100000000000000 * gene.index),
        }

      })

      if (!isNaN(datum.nodes[0]['chromosome']) || ['X', 'Y', 'MT'].includes(datum.nodes[0]['chromosome']) ){
        datum.name = "Chromosome " + datum.nodes[0]['chromosome']
      }
      else{
        datum.name =  datum.nodes[0]['chromosome']
      }

      return datum
    },
    process_ancestral(datum) {

      datum.domain = null
      datum.currentZoom = d3.zoomIdentity
      datum.selectedRegions = []
      datum.size_in_bp =  datum['nodes'].length
      datum.size_in_genes = datum['nodes'].length
      datum.unique_id = this.generateUniqueId()
      datum.type = 'ancestral'
      datum.name =  "Ancestral Chromosome"


      var look_up = {};

      // add neighbors and edges links to the nodes
      datum['nodes'].forEach(function(element) {
        element.neighbors = [];
        element.edges = {};
        look_up[element.id] = element
      });

      // add neighbors and edges links to the nodes
      datum['links'].forEach(function(element) {
        look_up[element.source].neighbors.push(look_up[element.target]);
        look_up[element.source].edges[look_up[element.target]] = element
        look_up[element.target].neighbors.push(look_up[element.source]);
        look_up[element.target].edges[look_up[element.source]] = element
      });

      // Sanity check
      var ends = [];


      Object.values(look_up).forEach(function(element) {

        switch (Object.keys(element.neighbors).length) {
          case 0:
            throw "No neighbor in this hog";
          case 1:
            ends.push(element);
            if (ends.length > 2) {
              throw "More than 2 ends in the contigs";
            }
            break;
          case 2:
            break;
          default:
            throw "More than 2 neighboring hogs"
        }

      });

      if (ends.length !== 2) {
        throw "Contigs dont have 2 ends."
      }

      // Flatten contig
      var previous = null
      var current = ends.sort((a, b) => a.id.toLowerCase().localeCompare(b.id.toLowerCase()))[0];
      var processing = true


      while (processing) {
        current.start = previous === null ? 0 : previous.end + 1;
        current.index = previous === null ? 0 : previous.index + 1;
        current.end = current.start + Math.random();


        if (previous != null && current.neighbors.length === 1) {
          previous = current;
          current = current.neighbors[0];
          processing = false;
        } else {
          let tmp = current
          current = current.neighbors[0] === previous ? current.neighbors[1] : current.neighbors[0];
          previous = tmp;
        }

        previous.edge = previous.edges[current];
      }

      datum.nodes.forEach(gene => {
        gene.data = {
          'datum1' : perlin.simplex2(0, gene.index),
          'datum2' : perlin.simplex2(0, 10000000 * gene.index),
          'datum3' : perlin.simplex2(0, 100000000000000 * gene.index),
        }

      })

      return datum


    },
    prepare_data() {

      const processFunction = this.settings.type_chromosome === 'extant' ? this.process_extant : this.process_ancestral;
      this.render_data = Object.values(this.jsonData)
          .filter(datum => datum.nodes.length > this.settings.min_genes)
          .map(processFunction);

    },

    // UTILS
    generateUniqueId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
    },

    // MODEL SETTERS
    updateDomain(index, newDomain) {
      this.sortedData[index].domain = newDomain;
    },
    updateZoom(index, newzoom) {
      this.sortedData[index].currentZoom =  newzoom;
    },
    addSelectedRegions(index, newSelectedRegions) {
      this.sortedData[index].selectedRegions.push(newSelectedRegions);
    },

    // MISC
    handleKeyup(event) {

      // modify the settings type_position when pressed the key 't'
      if (event.key === 't') {
        this.settings.type_position = this.settings.type_position === 'loci' ? 'index' : 'loci'
      }
    },
    configure_settings_user() {
      for(var key in this.user_settings) {
        var value = this.user_settings[key];
        this.settings[key] = value;
      }
    }
  },
  computed: {
    sortedData() {
    // Sort jsonData by some criteria in descending order
    switch (this.settings.sorting_chromosome) {
      case 'size':
        return [...this.render_data].sort((a, b) => (a.size_in_bp > b.size_in_bp) ? -1 : 1);
      case 'number_genes':
        return [...this.render_data].sort((a, b) => (a.size_in_genes > b.size_in_genes) ? -1 : 1);
      case 'name':
        return [...this.render_data].sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
      default:
        return [...this.render_data].sort((a, b) => a.id - b.id);

    }
  },
    domain_max() {
      const acc = this.settings.type_position === 'index' ? 'size_in_genes' : 'size_in_bp'
      return Math.max(...this.sortedData.map(d => d[acc]))
    }
}

}
</script>

